#include<stdio.h>
#include<windows.h>

long __stdcall PVectoredExceptionCallBack( EXCEPTION_POINTERS* expt_ptr_info );

int main()
{
	static bool first_execution = true;
	if (first_execution)
	{
		first_execution = false;
		/*registers an exception handler to catch the exception raised by raiseException function
		* returns the handle PVOID to the VectoredExceptionCallBack handler
		* PVectoreddExceptionCallback takes in pointer to an EXCEPTION_POINTERS
		* structure that recieves the exception record and contextRecord information
		* all the information and further manipulation of thread can be done
		* using this EXCEPTION_POINTERS structurte which is in parameter of callback
		*/
		AddVectoredExceptionHandler( 1, PVectoredExceptionCallBack );
		/*RaiseException function raises an exception in the calling thread with
		* an application defined exception code of the exception being raised.
		* it enables the process to use astructured excption handling to handle
		* private,software-generated,aplication defined exceptions
		* Can be viewed like throw statement of C++ returning an exception of a type
		* RaiseException raises exception in calling thread with application defined
		* exception-code of the exception being raised; and the application defined
		* exception flag that can be either 0 to indicate a continuable exception or
		* non-contnuable exception along with flag numbers and flagArray pointer
		* So basically like a throw statement of c++ exception handling
		*/
		RaiseException( STATUS_INTEGER_DIVIDE_BY_ZERO, 0, 0, 0 );
	}
	puts( "Second entry to main" );
	return 0;
}
/*typedef struct _EXCEPTION_POINTERS {
  PEXCEPTION_RECORD ExceptionRecord; //pointer to xception record
  PCONTEXT          ContextRecord; //pointer to context record
} EXCEPTION_POINTERS, *PEXCEPTION_POINTERS;
Contains an exception record with a machine-independent description
of an exception and a context record with a machine-dependent description of the processor context at the time of the exception.
*/
/* As the exception has been raised by RaiseException and a vecotredException
* Registered by AddVectoredExceptionHandler() function with priority 1(FIRST)
* PVectoredExceptionCallBack handler will be checked first after RaiseExcption
 */
long __stdcall PVectoredExceptionCallBack( EXCEPTION_POINTERS* excpt_ptr_info )
{
	if (excpt_ptr_info->ExceptionRecord->ExceptionCode == STATUS_INTEGER_DIVIDE_BY_ZERO)
		//view other values in ContextRecord and edit them.
		excpt_ptr_info->ContextRecord->Eip = (uintptr_t) &main;

	/*AddVectoredExceptionHandler allows you to register your own filter. RaiseException simply causes that exception to happen.

	We filter out our raised exception (STATUS_INTEGER_DIVIDE_BY_ZERO) Then edit the EIP to point to main( );

	This is the main exploitation area:
	You can change the Eip to any other function, diverting the code there. You can mess with all registers and flags too.

	Other ways to force an exception:

	Hardware breakpoints
	Memory Protection (PAGE_GUARD for example)
	Push back page to disk
	INT 3 breakpoint
	INT 1 step
	fault error (divide by zero, stack overflow etc.)
	Hard coded exception on the IDT.

	Control is always parsed to kernel mode before the exception handlers, so handling from there is always better than from a registered VEH.
	Also remember that Your VEH will only by at the top of the handler list if it was the last one added, debuggers may register to this list also. (some games have their own debugger).*/

	return 0;
}
